---
title: "TLS以及前置知识"
date: 2021-08-18T17:37:02+08:00
draft: false
categories: ["network","security"]
tags: ["tls","key","ca","cert","x509"]
---

## 对称加密与非对称加密

在密码学算法中，主要分成两种：对称加密与非对称加密

### 对称加密

即按照一定的算法，使用秘钥对于明文进行加密。之后，解密时使用同一把秘钥对密文进行解密。
常用算法：AES

### 非对称加密

即按照一定的算法，在加密时使用公钥（public key）进行加密，在解密时使用私钥（private key）进行解密。
也可以反之，用私钥加密，用公钥解密。但如果使用了私钥进行加密，由于公共秘钥是公开的，任何人都能用公钥按照既定算法解密，也就没有加密效果了。

常用算法：RSA

## 消息验证码

MAC的是Message Authentication Code的缩写，中文名叫消息验证码。使用MAC可以对消息的完整性进行验证，这样就可以看出消息是否被篡改，或在传输过程中破损。MAC算法需要通讯双方拥有同一把秘钥。在网络传输中，一般使用哈希算法作为MAC的加密基元，这种算法被叫做HMAC。

假设A向B发送消息，使用HMAC算法进行完整性校验（由于MAC算法只是为了保证消息完整性，故消息可以不用加密），A将待发送的消息和秘钥进行复杂的哈希运算，求出来哈希摘要并且追加在消息的末尾。B收到消息会用同样的方式在求一遍哈希摘要，如果追加在消息末尾的哈希摘要与计算出来的一致，则证明收到的消息是完整的。

## 数字签名

消息虽然经过MAC运算可以保证完整性，但是并不能够保证不可抵赖性。所谓的不可抵赖性是指，发送方发送的消息可以不承认消息是他发送的。这是因为双方秘钥相同，这样也就无法说明消息一定是发送方发出的。其也可能是接收方伪造的。

为了解决这个问题，可以使用上面说到的非对称加密的思路。发送方对消息计算出摘要，然后使用自己的私钥对摘要进行签名，最后将消息和摘要一同发送给接收方。接收方收到了消息后，对消息重新计算摘要，然后使用发送方的公钥解开签名得到摘要，如果新摘要和接收到的摘要一致，则证明此条消息是由发送方发送的。

由于只有发送方持有私钥，证明此消息的发送者唯一性，即不可抵赖。与MAC算法一样，数字签名算法也具备不可篡改性。

常用算法：RSA数字签名算法

## X.509标准与证书

虽然通过上面的技术可以达到消息不被篡改和不可抵赖，但是服务端可能是别人伪装的，客户端不能确定服务端就是其要找的真正服务端。要解决此问题就要引入一个可信的第三方认证机构来对服务端的身份进行背书。这个第三方认证机构，即Certificate Authority，简称CA。

### X.509
PKI是Public key infrastructure的缩写，即公钥基础设施，这是一个比较抽象的概念，包含了整个认证体系的各个部分软件、流程、法律等。目的是向客户端提供服务端的身份认证。国际上为了对PKI进行统一，所以就提出了统一的标准，最为常用的标准就是X.509标准。

X.509包含的内容非常庞杂，包括：

- CA为服务方签发证书，客户可以对服务方的证书进行验证
- CA审核服务方的身份的标准，签发流程
- 证书文件的结构
- 校验签名，包括证书链、域名、有效期
- 证书的撤销
- ......

### 证书

PKI中最重要的部分就是证书，了解了证书的结构和用法才能理解整个PKI的原理。

1. 服务方如果向CA申请证书，需向CA发送一个证书签名请求（Certificat signing request，即CSR），请求中包含了一个证明自身身份的CSR文件，文件结构如下（使用ASN.1标记法）：

```ASN.1
CertificationRequest ::= SEQUENCE {
	certificationRequestInfo CertificationRequestInfo,
	signatureAlgorithm AlgorithmIdentifier,
	signature BIT STRING
}
```

- SEQUENCE是一个结构体。
- certificationRequestInfo元素是CertificationRequestInfo类型的，其中存放请求信息核心内容，包括版本、服务方主体、服务方公钥......
- signatureAlgorithm元素是AlgorithmIdentifier类型的，即签名算法的标识符，标志着签名采用什么算法
- signature元素是BIT STRING，是服务方对于请求信息进行签名运算后的签名，以防服务方抵赖以及验证报文完整性

2. CA收到CSR后，会用CSR中有关服务方的信息签发证书，包含了如下的内容（使用ASN.1标记法）：
```ASN.1
Certificate ::= SEQUENCE {
	tbsCertificate TBSCertificate,
	signatureAlgorithm AlgorithmIdentifier,
	signature BIT STRING
}
```

- SEQUENCE是一个结构体。
- tbsCertificate元素是TBSCertificate类型的，其中存放证书的核心内容，包括签发者、服务方主体、有效期、扩展信息......
- signatureAlgorithm元素是AlgorithmIdentifier类型的，即签名算法的标识符，标志着签名采用什么算法
- signature元素是BIT STRING，也就是CA对证书进行签名运算后的签名


## TLS

TLS主要分为两个层：
1. 握手层：客户端和服务端交换一些信息，协议版本号、随机数、密码套件（密码算法集合），服务端就可以确定本次连接所用的密码套件。服务端向客户端发送证书，客户端来确认服务端的身份。然后进入了秘钥协商阶段，得到双方认可的秘钥，后续传输数据使用次秘钥进行加密。
2. 加密层：握手协商出来的秘钥算法和秘钥，接下来就进到加密层了。加密层就是用这些密码进行数据的加密以及完整性保护。由于非对称算法效率低，这里使用的算法是对称加密算法对传输的数据进行加密。